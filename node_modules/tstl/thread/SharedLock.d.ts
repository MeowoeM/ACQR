/** @module std */
import { ISharedLockable } from "../internal/thread/ISharedLockable";
import { ISharedTimedLockable } from "../internal/thread/ISharedTimedLockable";
export declare class SharedLock<Mutex extends IMutex> {
    private mutex_;
    constructor(mutex: Mutex);
    try_lock_for: "try_lock_shared_for" extends keyof Mutex ? (ms: number, closure: Closure) => Promise<boolean> : undefined;
    try_lock_until: "try_lock_shared_until" extends keyof Mutex ? (at: Date, closure: Closure) => Promise<boolean> : undefined;
    lock(closure: Closure): Promise<void>;
    try_lock(closure: Closure): Promise<boolean>;
}
export declare namespace SharedLock {
    function lock<Mutex extends Pick<ISharedLockable, "lock_shared" | "unlock_shared">>(mutex: Mutex, closure: Closure): Promise<void>;
    function try_lock<Mutex extends Pick<ISharedLockable, "try_lock_shared" | "unlock_shared">>(mutex: Mutex, closure: Closure): Promise<boolean>;
    function try_lock_for<Mutex extends Pick<ISharedTimedLockable, "try_lock_shared_for" | "unlock_shared">>(mutex: Mutex, ms: number, closure: Closure): Promise<boolean>;
    function try_lock_until<Mutex extends Pick<ISharedTimedLockable, "try_lock_shared_until" | "unlock_shared">>(mutex: Mutex, at: Date, closure: Closure): Promise<boolean>;
}
declare type IMutex = ISharedLockable & Partial<ISharedTimedLockable>;
declare type Closure = () => void | Promise<void>;
export {};
//# sourceMappingURL=SharedLock.d.ts.map